{"ast":null,"code":"import { createSelector, createEntityAdapter } from \"@reduxjs/toolkit\";\nimport { add, sub } from \"date-fns\";\nimport { apiSlice } from \"./apiSlice\";\n\n// ordenamos los posts por fecha\nconst postsAdapter = createEntityAdapter({\n  sortComparer: (a, b) => b.id - a.id\n});\n\n// Creamos el initalState con el postsAdapter\nconst initialState = postsAdapter.getInitialState();\n\n// Aqui vamos a llamar a la api con los diferente metodos HTTP\n\nexport const extendedApiSlice = apiSlice.injectEndpoints({\n  endpoints: builder => ({\n    getPosts: builder.query({\n      query: () => '/posts',\n      // Usamos el transformResponse para agregar la fecha, reacciones y tambien para noramlizar los datos con el postsAdapter.setAll\n      transformResponse: responseData => {\n        let min = 1;\n        const loadedPosts = responseData.map(post => {\n          if (!post.date) post.date = sub(new Date(), {\n            minutes: min++\n          }).toISOString();\n          return post;\n        });\n        return postsAdapter.setAll(initialState, loadedPosts);\n      },\n      // Aqui estamos pondiendo el tag para refrescar el cache, para cuando hagamos una mutacion se puedan mostrar los nuevos datos, \n      // basicamente cuando llamamos a este tag las publicaciones se van a volver a refrescar\n      providesTags: (result, error, arg) => [{\n        type: 'Post',\n        id: \"LIST\"\n      },\n      // aqui luego estamos poniendo un objecto para cada post individual pasando el id del post, y estamos haciendo esto mapieando el result\n      // y lo estamos esparciendo en diferentes post ids y terinaos con esto de type post y id por cada post,\n      // entonces si invalidamos alguno de estos post ids tambien se va a refrescar todos los posts.\n      ...result.ids.map(id => ({\n        type: 'Post',\n        id\n      }))]\n    }),\n    addNewPost: builder.mutation({\n      query: initialPost => ({\n        url: '/posts',\n        method: 'POST',\n        body: {\n          ...initialPost\n        }\n      }),\n      invalidatesTags: [{\n        type: 'Post',\n        id: \"LIST\"\n      }]\n    }),\n    updatePost: builder.mutation({\n      query: initialPost => ({\n        url: `posts/${initialPost.id}`,\n        method: 'PUT',\n        body: {\n          ...initialPost\n        }\n      }),\n      invalidatesTags: (result, error, arg) => [{\n        type: 'Post',\n        id: arg.id\n      }]\n    }),\n    deletePost: builder.mutation({\n      query: _ref => {\n        let {\n          id\n        } = _ref;\n        return {\n          url: `/posts/${id}`,\n          method: 'DELETE',\n          body: {\n            id\n          }\n        };\n      },\n      invalidatesTags: (result, error, arg) => [{\n        type: 'Post',\n        id: arg.id\n      }]\n    }),\n    getPostsByUserId: builder.query({\n      query: id => `posts/?userId=${id}`,\n      transformResponse: responseData => {\n        let min = 1;\n        const loadedPosts = responseData.map(post => {\n          if (!post.date) post.date = sub(new Date(), {\n            minutes: min++\n          }).toISOString();\n          return post;\n        });\n        return postsAdapter.setAll(initialState, loadedPosts);\n      },\n      providesTags: (result, error, arg) => [...result.ids.map(id => ({\n        type: 'Post',\n        id\n      }))]\n    })\n  })\n});\nexport const {\n  useGetPostsByUserIdQuery,\n  useUpdatePostMutation,\n  useDeletePostMutation,\n  useAddNewPostMutation,\n  useGetPostsQuery\n} = extendedApiSlice;\n\n// devuelve el resultado del query, pero es un objecto, nosostros queremos los datos entonces\nexport const selectPostsResult = extendedApiSlice.endpoints.getPosts.select();\n\n// entonces nesitamos usar el createSelector para create este selectPostsData y si recuerdas el createSelector recibe\n// una funcion input y despues tiene una funcion output entonces le pasamos el objecto query selectPostsResult como input\n// y despues el output esta tomando ese resultado y esta agarrando los datos como vemos ahi postsResult.data y ese dats tiene\n// ya los datos normalizados en el estado que tiene los ids y entites\nconst selectPostsData = createSelector(selectPostsResult, postsResult => postsResult.data);\n\n// Aqui agarramos el getSelectors donde crea los selectors y los renombramos con alias \nexport const {\n  selectAll: selectAllPosts,\n  selectById: selectPostById,\n  selectIds: selectPostIds\n  // Despues aqui pasamos el state y usamos el selectPostsData para decirle donde esta el estado y como vemos devuelve el estado normalizado\n  // pero podria ser null sobre todo la primera vez que cargamos la aplicacion y usamos este operador nullish que basicamente si el selectPostsData\n  // es null devuelve el initalState\n} = postsAdapter.getSelectors(state => {\n  var _selectPostsData;\n  return (_selectPostsData = selectPostsData(state)) !== null && _selectPostsData !== void 0 ? _selectPostsData : initialState;\n});","map":{"version":3,"names":["createSelector","createEntityAdapter","add","sub","apiSlice","postsAdapter","sortComparer","a","b","id","initialState","getInitialState","extendedApiSlice","injectEndpoints","endpoints","builder","getPosts","query","transformResponse","responseData","min","loadedPosts","map","post","date","Date","minutes","toISOString","setAll","providesTags","result","error","arg","type","ids","addNewPost","mutation","initialPost","url","method","body","invalidatesTags","updatePost","deletePost","_ref","getPostsByUserId","useGetPostsByUserIdQuery","useUpdatePostMutation","useDeletePostMutation","useAddNewPostMutation","useGetPostsQuery","selectPostsResult","select","selectPostsData","postsResult","data","selectAll","selectAllPosts","selectById","selectPostById","selectIds","selectPostIds","getSelectors","state","_selectPostsData"],"sources":["/home/agust/Cursos/Redux-Toolkit/71-rtk-query-advanced/src/features/postsSlice.js"],"sourcesContent":["import { createSelector, createEntityAdapter } from \"@reduxjs/toolkit\";\nimport { add, sub } from \"date-fns\";\nimport { apiSlice } from \"./apiSlice\";\n\n// ordenamos los posts por fecha\nconst postsAdapter = createEntityAdapter({\n    sortComparer: ((a, b) => b.id - a.id)\n});\n\n// Creamos el initalState con el postsAdapter\nconst initialState = postsAdapter.getInitialState();\n\n// Aqui vamos a llamar a la api con los diferente metodos HTTP\n\nexport const extendedApiSlice = apiSlice.injectEndpoints({\n    endpoints: builder => ({\n        getPosts: builder.query({\n            query: () => '/posts',\n            // Usamos el transformResponse para agregar la fecha, reacciones y tambien para noramlizar los datos con el postsAdapter.setAll\n            transformResponse: responseData => {\n                let min  = 1;\n                const loadedPosts = responseData.map( post => {\n                    if (!post.date) post.date = sub(new Date(), { minutes: min ++ }).toISOString()\n                    return post\n                })\n                return postsAdapter.setAll(initialState, loadedPosts)\n            },\n            // Aqui estamos pondiendo el tag para refrescar el cache, para cuando hagamos una mutacion se puedan mostrar los nuevos datos, \n            // basicamente cuando llamamos a este tag las publicaciones se van a volver a refrescar\n            providesTags: (result, error, arg) => [\n                { type: 'Post', id: \"LIST\" },\n                // aqui luego estamos poniendo un objecto para cada post individual pasando el id del post, y estamos haciendo esto mapieando el result\n                // y lo estamos esparciendo en diferentes post ids y terinaos con esto de type post y id por cada post,\n                // entonces si invalidamos alguno de estos post ids tambien se va a refrescar todos los posts.\n                ...result.ids.map(id => ({ type: 'Post', id }))\n            ]\n        }),\n        addNewPost: builder.mutation({\n            query: initialPost => ({\n                url: '/posts',\n                method: 'POST',\n                body: { ...initialPost }\n            }),\n            invalidatesTags: [\n                { type: 'Post', id: \"LIST\" }\n            ]\n        }),\n        updatePost: builder.mutation({\n            query: initialPost => ({\n                url: `posts/${initialPost.id}`,\n                method: 'PUT',\n                body: { ...initialPost }\n            }), \n            invalidatesTags: (result, error, arg) => [\n                { type: 'Post',id: arg.id }\n            ]\n        }), \n        deletePost: builder.mutation({\n            query: ({ id }) => ({\n                url: `/posts/${id}`,\n                method: 'DELETE',\n                body: { id }\n            }), \n            invalidatesTags: (result, error, arg) => [\n                { type: 'Post', id: arg.id }\n            ]\n        }), getPostsByUserId: builder.query({\n            query: id => `posts/?userId=${id}`,\n            transformResponse: responseData => {\n                let min  = 1;\n                const loadedPosts = responseData.map( post => {\n                    if (!post.date) post.date = sub(new Date(), { minutes: min ++ }).toISOString()\n                    return post\n                })\n                return postsAdapter.setAll(initialState, loadedPosts)\n            },\n            providesTags: (result, error, arg) => [\n                ...result.ids.map(id => ({ type: 'Post', id })) \n            ]\n        })\n    })\n});\n\nexport const { \n    useGetPostsByUserIdQuery,\n    useUpdatePostMutation,\n    useDeletePostMutation,\n    useAddNewPostMutation,\n    useGetPostsQuery, \n} = extendedApiSlice;\n\n// devuelve el resultado del query, pero es un objecto, nosostros queremos los datos entonces\nexport const selectPostsResult = extendedApiSlice.endpoints.getPosts.select();\n\n// entonces nesitamos usar el createSelector para create este selectPostsData y si recuerdas el createSelector recibe\n// una funcion input y despues tiene una funcion output entonces le pasamos el objecto query selectPostsResult como input\n// y despues el output esta tomando ese resultado y esta agarrando los datos como vemos ahi postsResult.data y ese dats tiene\n// ya los datos normalizados en el estado que tiene los ids y entites\nconst selectPostsData = createSelector(\n    selectPostsResult,\n    postsResult => postsResult.data\n)\n\n// Aqui agarramos el getSelectors donde crea los selectors y los renombramos con alias \nexport const { \n    selectAll: selectAllPosts,\n    selectById: selectPostById, \n    selectIds: selectPostIds \n    // Despues aqui pasamos el state y usamos el selectPostsData para decirle donde esta el estado y como vemos devuelve el estado normalizado\n    // pero podria ser null sobre todo la primera vez que cargamos la aplicacion y usamos este operador nullish que basicamente si el selectPostsData\n    // es null devuelve el initalState\n} = postsAdapter.getSelectors(state => selectPostsData(state) ?? initialState) \n\n\n\n\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}